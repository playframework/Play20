# Javascript Routing

The play router is able to generate Javascript code to handle routing from Javascript running client side back to your
application. This aids in refactoring your application, if you change the structure of your URLs or parameter names,
your Javascript gets automatically updated to use that new structure.

## Generating a Javascript reverse router

The first step to using Plays Javascript reverse router is to generate it. The router will only expose the routes that you
explicitly tell it to, thus minimising the size of the Javascript code and also avoiding unnecessarily giving away all
the information about the structure of your application.

There are two ways to generate a Javascript reverse router, one is to embed the it in the HTML page using template
directives, the other is to generate a Javascript resource in an action that can be downloaded, cached and shared between
pages.

### Embedded reverse router

An embedded router can be generated using the ``@javascriptRouter`` directive inside a Scala template. Typically this
might be done inside the main decorating template.

    @helper.javascriptRouter("Routes")(
      routes.javascript.Users.list,
      routes.javascript.Users.get
    )

The first parameter is the name of the global variable that the reverse router will be placed in. The second parameter is the
list of Javascript routes that should be included in this reverse router. In order to use this function, your template must
have an implicit RequestHeader in scope, for example this can be made available by adding ``(implicit req:
RequestHeader)`` to the end of your parameters declaration.

### Reverse router resource

A reverse router resource can be generated by creating an action that invokes the reverse router generator. It has a
similar syntax to embedding the router in a template:

    val javascriptRoutes = Action { implicit request =>
      import routes.javascript._
      Ok(
        Routes.javascriptRouter("Routes")(
          Users.list,
          Users.get
        )
      ).as(JAVASCRIPT)
    }

Having implemented this action, and of course added it to your routes file, you can then include it as a resource in
your templates:

    <script type="text/javascript" src="@routes.Application.javascriptRoutes"></script>

## Using the reverse router

The reverse router generator produces a global JavaScript object that can compute the URLs of your actions. Just call the
fully qualified name of your action with appropriate parameters and you will get back an object containing useful
information about this action:

    var route = Routes.controllers.Users.get(someId);
    console.log(route.url); // prints the URL of the action, e.g. "/user/42"
    console.log(route.method); // prints the action’s method, e.g. "GET"
    console.log(route.absoluteURL()); // prints the absolute URL, e.g. "http://localhost:9000/user/42"
    console.log(route.absoluteURL({ secure: true })); // prints the URL using HTTPS, e.g. "https://localhost:9000/user/42"
    console.log(route.webSocketURL()); // prints a Web Socket URL, e.g. "ws://localhost:9000/user/42"
    console.log(route.webSocketURL({ secure: true })); // prints the URL using WSS, e.g. "wss://localhost:9000/user/42"

    
### Making Ajax requests

You can make the code generator produce an additional ``ajax`` method to the routes by setting the ``ajaxMethod``
parameter to ``true``:

    Routes.javascriptRouter("Routes", ajaxMethod = true)(/*…*/)

The ``ajax`` method can then be used as follows:

    Routes.controllers.Users.get(someId).ajax({
      success: function (data, xhr) { /*…*/ },
      error: function (xhr) { /*…*/ }
    });
    
The ``ajax`` method can take an object as parameter with a ``success`` or an ``error`` fields. The ``success`` callback
will be called if the Ajax call succeeds, with the response data and the underlying XMLHttpRequest object
as parameters. The ``error`` callback will be called in case of failure, with the underlying XMLHttpRequest object as parameter.

If the request needs to have a body (e.g. to submit a form asynchronously), you can pass an additional ``data`` parameter
containing a hash of values that will be send in the request body as a ``FormData`` value.

The ``ajax`` method returns the XMLHttpRequest object used to perform the request.

### Using a custom ajax method

You can define your own ``ajax`` method if you want to have more control on the way the Ajax call is performed. You can pass
a JavaScript function as a parameter of the reverse router generator. The following example shows how to use jQuery:

    Routes.javascriptRouter("Routes", ajaxMethod = "function (s) { s.url = this.url; s.type = this.method; return $.ajax(s) }")(/*…*/)

Then, calling the ``ajax`` method on a JavaScript route will call the function defined in ``ajaxMethod`` with the same
parameters and with ``this`` bound to the route object.